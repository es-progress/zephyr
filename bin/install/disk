#!/usr/bin/env bash
#############
## Zephyr  ##
##         ##
## Install ##
## Disk    ##
#############

###############
## FUNCTIONS ##
###############

## Destroy partition table
##
## @param    $1  Disk device
############################
_partition-zap() {
    local device="${1:?Disk device missing}"
    sgdisk --zap-all "${device}"

    # Inform kernel about partitions
    partprobe "${device}"
    sleep 3
}

## Create partition
##
## @param    $1  Disk device
## @param    $2  Partition number
## @param    $3  Gap (free space before this partition)
## @param    $4  Size
## @param    $5  Type
##               luks, efi, msr, win, linux, swap
## @param    $6  Label
#######################################################
_partition-create() {
    local device="${1:?Disk device missing}"
    local number="${2:?Partition number missing}"
    local gap="${3:?Gap size missing}"
    local size="${4:?Partition size missing}"
    local type="${5:?Partition type missing}"
    local label="${6:?Partition label missing}"
    local type_code

    case "${type}" in
        luks) type_code=8309 ;;
        efi) type_code=ef00 ;;
        msr) type_code=0c01 ;;
        win) type_code=0700 ;;
        linux) type_code=8300 ;;
        swap) type_code=8200 ;;
        *)  # Use type as is
            type_code="${type}" ;;
    esac

    sgdisk --new="${number}:+${gap}:+${size}" --typecode="0:${type_code}" --change-name="0:${label}" "${device}"

    # Inform kernel about partitions
    partprobe "${device}"
    sleep 3
}

## Encrypt partition/volume with LUKS
##
## @param    $1  Partition/volume device
## @param    $2  LUKS Type (luks1, luks2)
## @param    $3  Label
#########################################
_encrypt-partition() {
    local device="${1:?Partition device missing}"
    local type="${2:?LUKS type missing}"
    local label="${3:?Partition label missing}"
    local luks2_options=()

    [[ "${type}" == luks2 ]] && luks2_options=(--pbkdf=argon2id --pbkdf-memory=2097152)

    cryptsetup luksFormat \
        "--type=${type}" \
        --hash=sha512 \
        --cipher=aes-xts-plain64 \
        --key-size=512 \
        --use-urandom \
        --iter-time=3000 \
        "${luks2_options[@]}" -- "${device}"
    _decrypt-partition "${device}" "${label}"
}

## Decrypt (open) partition/volume
##
## @param    $1  Partition/volume device
## @param    $2  Label
########################################
_decrypt-partition() {
    local device="${1:?Partition device missing}"
    local label="${2:?Partition label missing}"

    cryptsetup open \
        --type luks \
        "${device}" "${label}"
}

## Create LVM physical volume
##
## @param    $1  Device
#############################
_pv-create() {
    local device="${1:?PV device missing}"
    pvcreate "${device}"
}

## Create LVM volume group
##
## @param    $1  Volume group name
## @param    $2  Comma-separated list of PV devices
###################################################
_vg-create() {
    local vg="${1:?VG name missing}"
    local pv_devices="${2:?PV devices missing}"
    local pv_devices_array=()
    local pv_device

    IFS="," read -r -a pv_devices_array <<<"${pv_devices}"
    for pv_device in "${pv_devices_array[@]}"; do
        print-header Create PV from "${pv_device}"...
        _pv-create "${pv_device}"
        print-finish
    done

    vgcreate --autobackup y "${vg}" "${pv_devices_array[@]}"
}

## Create LVM logical volume
##
## @param    $1  Volume group name
## @param    $2  Logical volume name
## @param    $3  Size, in exact bytes or percentage
###################################################
_lv-create() {
    local vg="${1:?VG name missing}"
    local lv="${2:?LV name missing}"
    local size="${3:?Size missing}"
    local size_param=()

    # Check if size has a percentage
    if [[ "${size}" =~ ^[0-9]+% ]]; then
        size_param=(--extents "${size}")
    else
        size_param=(--size "${size}")
    fi

    lvcreate --autobackup y --name "${lv}" "${size_param[@]}" "${vg}"
}

## Print disk info
##################
_disk_info() {
    local disk
    local devices=()
    for disk in "${disks[@]}"; do
        devices+=("${disk_devices[${disk}]}")
    done

    print-section Disks
    fdisk -l "${devices[@]}"

    print-section LVM
    print-header Volume groups
    vgs
    print-header Physical volumes
    pvs
    print-header Logical volumes
    lvs

    print-section Filesystems
    # Exclude loopback devices (7) and cdrom devices (11)
    lsblk --fs --exclude 7,11
}

## Partition disks
##################
_partition() {
    local disk partition disk_device number gap size type label crypt filesystem
    local partitions_array=()

    # Print parsed disk map
    print-section Parsed disk map
    for disk in "${disks[@]}"; do
        echo "Disk: ${disk}"
        echo Partitions:
        printf "%-15s%6s%6s %-6s%-15s%-6s%-8s\n" "#part_device" gap size type label crypt filesystem
        IFS=";" read -r -a partitions_array <<<"${disk_partitions["${disk}"]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r disk_device number gap size type label crypt filesystem <<< "${partition}"
            printf "%-15s%6s%6s %-6s%-15s%-6s%-8s\n" "${disk_device}${number}" "${gap}" "${size}" "${type}" "${label}" "${crypt}" "${filesystem}"
        done
        echo -----------------------------------------------------------------
    done

    # Show what we are going to do
    print-section Disks and partitions in the system
    lsblk -o NAME,LABEL,FSTYPE,SIZE,MODEL -e7,11
    echo
    print-warning "WARNING! The following disks will be erased!"
    for disk in "${disks[@]}"; do
        print-warning "${disk_devices[${disk}]}"
    done
    echo
    read -rp "Proceed? (yes/no): "
    [[ ${REPLY,,} != yes && ${REPLY,,} != y ]] && error-exit Aborted.

    # Do the partitioning
    for disk in "${disks[@]}"; do
        disk_device="${disk_devices[${disk}]}"
        print-section Partition "${disk_device}"

        print-header Destroy partition table on "${disk_device}" "(${disk})..."
        _partition-zap "${disk_device}"
        print-finish

        IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r _ number gap size type label _ _ <<< "${partition}"
            print-header Create partition: "${label}..."
            _partition-create "${disk_device}" "${number}" "${gap}" "${size}" "${type}" "${label}"
            print-finish
        done
        print-finish Finished partitioning "${disk_device}"
    done
    print-finish All partitioning finished.
}

## Encrypt partitions/volumes
#############################
_encrypt() {
    local disk partition disk_device number label crypt
    local partitions_array=()

    # Do the encryption
    for disk in "${disks[@]}"; do
        IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r disk_device number _ _ _ label crypt _ <<< "${partition}"
            [[ "${crypt}" != luks* ]] && continue

            print-header LUKS encrypting "${disk_device}${number} (${label})..."
            _encrypt-partition "${disk_device}${number}" "${crypt}" "${label}"
            print-finish
        done
    done
    print-finish All encryption finished.
}

## Decrypt partitions/volumes
#############################
_decrypt() {
    local disk partition disk_device number label crypt
    local partitions_array=()

    # Do the decryption
    for disk in "${disks[@]}"; do
        IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r disk_device number _ _ _ label crypt _ <<< "${partition}"
            [[ "${crypt}" != luks* ]] && continue

            print-header Open encrypted partition "${disk_device}${number} (${label})..."
            _decrypt-partition "${disk_device}${number}" "${label}"
            print-finish
        done
    done
    print-finish All decryption finished.
}

## Setup LVM
############
_lvm() {
    local vg pvs_array pv lvs_array lv name size crypt filesystem

    # Print parsed disk map
    print-section Parsed disk map
    for vg in "${vol_groups[@]}"; do
        echo "Volume group: ${vg}"

        echo Physical volumes:
        IFS="," read -r -a pvs_array <<<"${vol_group_pvs["${vg}"]}"
        for pv in "${pvs_array[@]}"; do
            echo "${pv}"
        done

        echo Logical volumes:
        printf "%-15s%10s %-6s%-8s\n" name size crypt filesystem
        IFS=";" read -r -a lvs_array <<<"${vol_group_lvs["${vg}"]}"
        for lv in "${lvs_array[@]}"; do
            IFS=, read -r name size crypt filesystem <<< "${lv}"
            printf "%-15s%10s %-6s%-8s\n" "${name}" "${size}" "${crypt}" "${filesystem}"
        done
        echo ------------------------------------------
    done

    read -rp "Proceed? (yes/no): "
    [[ ${REPLY,,} != yes && ${REPLY,,} != y ]] && error-exit Aborted.

    # Do the LVM setup
    for vg in "${vol_groups[@]}"; do
        print-header Create volume group "${vg}"...
        _vg-create "${vg}" "${vol_group_pvs[${vg}]}"
        print-finish

        # Create logical volumes
        IFS=";" read -r -a lvs_array <<<"${vol_group_lvs["${vg}"]}"
        for lv in "${lvs_array[@]}"; do
            IFS=, read -r name size _ _ <<< "${lv}"
            print-header Create logical volume "${name}"...
            _lv-create "${vg}" "${name}" "${size}"
            print-finish
        done
    done
}

##################
## SCRIPT START ##
##################

# Strict mode
set -eufo pipefail
IFS=$'\n\t'

source "${PROJECT_ROOT}/bin/bootstrap.sh"
check-root

subcommand="${1:?Subcommand missing}"
profile="${2:?Profile missing}"
shift 2

# Parse disk maps
disks=()
declare -A disk_devices
declare -A disk_part_prefixes
declare -A disk_partitions
vol_groups=()
declare -A vol_group_pvs
declare -A vol_group_lvs
for map in "${@}"; do
    # shellcheck disable=SC2310,SC2311
    if file=$(cfg-get "${profile}" "install/disk-maps/${map}"); then

        # Parse disks
        for line in $(cfg-read "${file}" disks); do
            IFS=$' \t' read -r -a arguments <<<"${line}"
            disk="${arguments[0]}"
            disk_device="${arguments[1]}"
            disk_part_prefix="${arguments[2]:-}"

            disks+=("${disk}")
            disk_devices["${disk}"]="${disk_device}"
            disk_part_prefixes["${disk}"]="${disk_part_prefix}"
        done

        # Parse partitions
        for line in $(cfg-read "${file}" partitions); do
            IFS=$' \t' read -r -a arguments <<<"${line}"
            disk="${arguments[0]}"
            # Rewrite disk_name to disk_device with partition prefix
            arguments[0]="${disk_devices["${disk}"]}${disk_part_prefixes["${disk}"]}"

            partition_info="$(implode , "${arguments[@]}")"
            if [[ -z "${disk_partitions[${disk}]:-}" ]]; then
                disk_partitions[${disk}]="${partition_info}"
            else
                disk_partitions[${disk}]="${disk_partitions[${disk}]};${partition_info}"
            fi
        done

        # Parse vol-groups
        for line in $(cfg-read "${file}" vol-groups); do
            IFS=$' \t' read -r -a arguments <<<"${line}"
            vol_group="${arguments[0]}"

            # Rewrite PV labels to device files
            pv_devices=()
            IFS="," read -r -a pvs_array <<<"${arguments[1]}"
            for pv in "${pvs_array[@]}"; do
                # Find partition definition for PV
                for disk in "${disks[@]}"; do
                    IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
                    for partition in "${partitions_array[@]}"; do
                        IFS=, read -r disk_device number _ _ _ label crypt _ <<< "${partition}"

                        [[ "${pv}" != "${label}" ]] && continue

                        # Check partition is encrypted
                        if [[ "${crypt}" == luks* ]]; then
                            # Rewrite to LUKS device
                            pv_devices+=("/dev/mapper/${label}")
                        else
                            # Rewrite to partition device
                            pv_devices+=("${disk_device}${number}")
                        fi
                    done
                done
            done

            vol_groups+=("${vol_group}")
            vol_group_pvs["${vol_group}"]="$(implode , "${pv_devices[@]}")"
        done

        # Parse volumes
        for line in $(cfg-read "${file}" volumes); do
            IFS=$' \t' read -r -a arguments <<<"${line}"
            vol_group="${arguments[0]}"
            # Remove vol-group name from arguments
            unset "arguments[0]"

            volume_info="$(implode , "${arguments[@]}")"
            if [[ -z "${vol_group_lvs[${vol_group}]:-}" ]]; then
                vol_group_lvs[${vol_group}]="${volume_info}"
            else
                vol_group_lvs[${vol_group}]="${vol_group_lvs[${vol_group}]};${volume_info}"
            fi
        done
    else
        error-exit Map not found: "${map}"
    fi
done

# Perform the requested action
case "${subcommand}" in
    decrypt) _decrypt ;;
    encrypt) _encrypt ;;
    info) _disk_info ;;
    lvm) _lvm ;;
    partition) _partition ;;
    *) error-exit Invalid subcommand: "${subcommand}" ;;
esac

exit 0
