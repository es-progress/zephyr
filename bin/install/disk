#!/usr/bin/env bash
#############
## Zephyr  ##
##         ##
## Install ##
## Disk    ##
#############

###############
## FUNCTIONS ##
###############

## Destroy partition table
##
## @param    $1  Disk device
############################
_partition-zap() {
    local device="${1:?Disk device missing}"
    sgdisk --zap-all "${device}"

    # Inform kernel about partitions
    partprobe "${device}"
    sleep 3
}

## Create partition
##
## @param    $1  Disk device
## @param    $2  Partition number
## @param    $3  Gap (free space before this partition)
## @param    $4  Size
## @param    $5  Type
##               luks, efi, msr, win, linux, swap
## @param    $6  Label
#######################################################
_partition-create() {
    local device="${1:?Disk device missing}"
    local number="${2:?Partition number missing}"
    local gap="${3:?Gap size missing}"
    local size="${4:?Partition size missing}"
    local type="${5:?Partition type missing}"
    local label="${6:?Partition label missing}"
    local type_code

    case "${type}" in
        luks) type_code=8309 ;;
        efi) type_code=ef00 ;;
        msr) type_code=0c01 ;;
        win) type_code=0700 ;;
        linux) type_code=8300 ;;
        swap) type_code=8200 ;;
        *)  # Use type as is
            type_code="${type}" ;;
    esac

    sgdisk --new="${number}:+${gap}:+${size}" --typecode="0:${type_code}" --change-name="0:${label}" "${device}"

    # Inform kernel about partitions
    partprobe "${device}"
    sleep 3
}

## Encrypt partition/volume with LUKS
##
## @param    $1  Partition/volume device
## @param    $2  LUKS Type (luks1, luks2)
## @param    $3  Label
#########################################
_encrypt-partition() {
    local device="${1:?Partition device missing}"
    local type="${2:?LUKS type missing}"
    local label="${3:?Partition label missing}"
    local luks2_options=()

    [[ "${type}" == luks2 ]] && luks2_options=(--pbkdf=argon2id --pbkdf-memory=2097152)

    cryptsetup luksFormat \
        "--type=${type}" \
        --hash=sha512 \
        --cipher=aes-xts-plain64 \
        --key-size=512 \
        --use-urandom \
        --iter-time=3000 \
        "${luks2_options[@]}" -- "${device}"
    _decrypt-partition "${device}" "${label}"
}

## Decrypt (open) partition/volume
##
## @param    $1  Partition/volume device
## @param    $2  Label
########################################
_decrypt-partition() {
    local device="${1:?Partition device missing}"
    local label="${2:?Partition label missing}"

    cryptsetup open \
        --type luks \
        "${device}" "${label}"
}

## Print disk info
##################
_disk_info() {
    local disk
    local devices=()
    for disk in "${disks[@]}"; do
        devices+=("${disk_devices[${disk}]}")
    done

    print-section Disks
    fdisk -l "${devices[@]}"

    print-section Filesystems
    # Exclude loopback devices (7) and cdrom devices (11)
    lsblk --fs --exclude 7,11
}

## Partition disks
##################
_partition() {
    local disk partition disk_device number gap size type label crypt volgroup filesystem
    local partitions_array=()

    # Print parsed disk map
    print-section Parsed disk map
    for disk in "${disks[@]}"; do
        echo "Disk: ${disk}"
        echo Partitions:
        printf "%-15s%6s%6s %-6s%-15s%-6s%-15s%-8s\n" "#part_device" gap size type label crypt volgroup filesystem
        IFS=";" read -r -a partitions_array <<<"${disk_partitions["${disk}"]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r disk_device number gap size type label crypt volgroup filesystem <<< "${partition}"
            printf "%-15s%6s%6s %-6s%-15s%-6s%-15s%-8s\n" "${disk_device}${number}" "${gap}" "${size}" "${type}" "${label}" "${crypt}" "${volgroup}" "${filesystem}"
        done
        echo --------------------------------------------------------------------------------
    done

    # Show what we are going to do
    print-section Disks and partitions in the system
    lsblk -o NAME,LABEL,FSTYPE,SIZE,MODEL -e7,11
    echo
    print-warning "WARNING! The following disks will be erased!"
    for disk in "${disks[@]}"; do
        print-warning "${disk_devices[${disk}]}"
    done
    echo
    read -rp "Proceed? (yes/no): "
    [[ ${REPLY,,} != yes && ${REPLY,,} != y ]] && error-exit Aborted.

    # Do the partitioning
    for disk in "${disks[@]}"; do
        disk_device="${disk_devices[${disk}]}"
        print-section Partition "${disk_device}"

        print-header Destroy partition table on "${disk_device}" "(${disk})..."
        _partition-zap "${disk_device}"
        print-finish

        IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r _ number gap size type label _ _ _ <<< "${partition}"
            print-header Create partition: "${label}..."
            _partition-create "${disk_device}" "${number}" "${gap}" "${size}" "${type}" "${label}"
            print-finish
        done
        print-finish Finished partitioning "${disk_device}"
    done
    print-finish All partitioning finished.
}

## Encrypt partitions/volumes
#############################
_encrypt() {
    local disk partition disk_device number label crypt
    local partitions_array=()

    # Do the encryption
    for disk in "${disks[@]}"; do
        IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r disk_device number _ _ _ label crypt _ _ <<< "${partition}"
            [[ "${crypt}" != luks* ]] && continue

            print-header LUKS encrypting "${disk_device}${number} (${label})..."
            _encrypt-partition "${disk_device}${number}" "${crypt}" "${label}"
            print-finish
        done
    done
    print-finish All encryption finished.
}

## Decrypt partitions/volumes
#############################
_decrypt() {
    local disk partition disk_device number label crypt
    local partitions_array=()

    # Do the decryption
    for disk in "${disks[@]}"; do
        IFS=";" read -r -a partitions_array <<<"${disk_partitions[${disk}]}"
        for partition in "${partitions_array[@]}"; do
            IFS=, read -r disk_device number _ _ _ label crypt _ _ <<< "${partition}"
            [[ "${crypt}" != luks* ]] && continue

            print-header Open encrypted partition "${disk_device}${number} (${label})..."
            _decrypt-partition "${disk_device}${number}" "${label}"
            print-finish
        done
    done
    print-finish All decryption finished.
}

##################
## SCRIPT START ##
##################

# Strict mode
set -eufo pipefail
IFS=$'\n\t'

source "${PROJECT_ROOT}/bin/bootstrap.sh"
check-root

subcommand="${1:?Subcommand missing}"
profile="${2:?Profile missing}"
shift 2

# Parse disk maps
disks=()
declare -A disk_devices
declare -A disk_part_prefixes
declare -A disk_partitions
for map in "${@}"; do
    # shellcheck disable=SC2310,SC2311
    if file=$(cfg-get "${profile}" "install/disk-maps/${map}"); then

        # Parse disks
        for line in $(cfg-read "${file}" disks); do
            IFS=$' \t' read -r -a arguments <<<"${line}"
            disk="${arguments[0]}"
            disk_device="${arguments[1]}"
            disk_part_prefix="${arguments[2]:-}"

            disks+=("${disk}")
            disk_devices["${disk}"]="${disk_device}"
            disk_part_prefixes["${disk}"]="${disk_part_prefix}"
        done

        # Parse partitions
        for line in $(cfg-read "${file}" partitions); do
            IFS=$' \t' read -r -a arguments <<<"${line}"
            disk="${arguments[0]}"
            # Rewrite disk_name to disk_device with partition prefix
            arguments[0]="${disk_devices["${disk}"]}${disk_part_prefixes["${disk}"]}"

            partition_info="$(implode , "${arguments[@]}")"
            if [[ -z "${disk_partitions[${disk}]:-}" ]]; then
                disk_partitions[${disk}]="${partition_info}"
            else
                disk_partitions[${disk}]="${disk_partitions[${disk}]};${partition_info}"
            fi
        done
    else
        error-exit Map not found: "${map}"
    fi
done

# Perform the requested action
case "${subcommand}" in
    decrypt) _decrypt ;;
    encrypt) _encrypt ;;
    info) _disk_info ;;
    partition) _partition ;;
    *) error-exit Invalid subcommand: "${subcommand}" ;;
esac

exit 0
